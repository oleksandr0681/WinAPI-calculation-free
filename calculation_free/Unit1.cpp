//---------------------------------------------------------------------------
// Программа для расчёта стоимости изготовления изделия и других расчётов.
// Программа "Calculation" (Расчёт) распространяется на условиях "как есть".
// Все права на "Calculation" принадлежат автору: Вербе Александру.
// Никто, кроме автора, не имеет права изменять исходный код программы.
// При расчёте рекомендуется применение объектно-ориентированного
// программирования.

#include <windows.h>
#include <math.h>
#include <stdio.h>
#include "cost.h"
// Структура prime_cost, расчитывает стоимость изготовления изделия.
#include "menu.h"
// Определение констант меню.
#include "dialog.h"
// Определение констант диалогового окна.
#include "image.h"
// Определение констант пиктограммы.

LRESULT	CALLBACK WndProc (HWND, UINT, WPARAM, LPARAM);
// Оконная функция для главного окна.
BOOL	CALLBACK dialog_function_for_prime_cost (HWND, UINT, WPARAM, LPARAM);
// Оконная функция для диалогового окна "Расчёт стоимости изготовления
// изделия".
BOOL	CALLBACK dialog_function_for_sling (HWND, UINT, WPARAM, LPARAM);
// Оконная функция для диалогового окна "Расчёт натяжения стропа".
BOOL	CALLBACK dialog_function_for_license (HWND, UINT, WPARAM, LPARAM);
// Оконная функция для диалогового окна "Лицензионный договор".
BOOL	CALLBACK dialog_function_for_about (HWND, UINT, WPARAM, LPARAM);
// Оконная функция для диалогового окна "О программе".

//---------------------------------------------------------------------------

WINAPI WinMain
(
	HINSTANCE program_description,
	// Дескриптор (описатель), который Windows присваивает запущенной
	// программе (приложению).
	HINSTANCE prev_program_description,
	// Этот параметр остался для совместимости версий от Windows 3.x, где он
	// использовался для представления дескриптора предыдущего экземпляра
	// программы. В Win32 этот параметр не используется и поэтому всегда
	// принимает нулевое значение.
	LPSTR cmd_line,
	// Указатель на строку, в которую копируются аргументы программы
	// (приложения), если она запущена в режиме командной строки.
	int window_condition
	// Целое значение, которое может быть передано функции ShowWindow.	
)
{
	HWND window_description;
	// Дескриптор (описатель) окна.
	char window_class_name[]="window_class";
	// Имя класса окна.
	WNDCLASSEX wc;
	// Структура главного окна программы.
	// Структура представляет собой класс, все члены которого по умолчанию
	// открыты (public).
	MSG msg;

	// Заполняем структуру главного окна.
	wc.cbSize=sizeof(wc);
	// Размер данной структуры в байтах.
	wc.style=CS_HREDRAW | CS_VREDRAW;
	// Стиль класса окна.
	wc.lpfnWndProc=WndProc;
	// Указатель на оконную процедуру (функцию окна).
	wc.cbClsExtra=0;
	// Число дополнительных байтов, которые должны быть распределены в
	// конце структуры.
	wc.cbWndExtra=0;
	// Число дополнительных байтов, которые должны быть распределены вслед
	// за экземпляром окна.
	wc.hInstance=program_description;
	// Дескриптор, который Windows присваивает запущенной программе (в
	// которой находится оконная процедура для структуры  окна приложения).
	wc.hIcon=LoadIcon(NULL, IDI_APPLICATION);
    // Дескриптор пиктограммы.
	wc.hCursor=LoadCursor(NULL, IDC_ARROW);
    // Дескриптор курсора.
//	wc.hbrBackground=(HBRUSH)GetStockObject(WHITE_BRUSH);
	wc.hbrBackground=(HBRUSH)CreateSolidBrush(RGB(235,220,180));
	// Дескриптор кисти, используемой для закраски фона окна.
	// 255.240.200	светло-коричневый цвет.
	// 235.220.180	светло-коричневый цвет.
	// 220.200.180	светло-коричневый цвет.
	// 224.192.144	светло-коричневый цвет.
	// 224.192.0	светло-коричневый цвет.
	// 192.160.0	коричневый цвет.
	wc.lpszMenuName="main_menu";
	// Указатель на строку, содержащую имя меню, применяемого по умолчанию
	// для этого класса.
	wc.lpszClassName=window_class_name;
    // Указатель на строку, содержащую имя класса окна.
	wc.hIconSm=LoadIcon(NULL, IDI_APPLICATION);
    // Дескриптор малой пиктограммы.

	// Регистрируем структуру (класс) окна.
	if(!RegisterClassEx(&wc))
	{
    	char message[100]="Cannot register class: ";
		strcat(message, window_class_name);
		MessageBox
		// Функция создаёт, отображает и обслуживает окно сообщений.
		(
		NULL,
		// Дескриптор родительского окна. Он принимает значение NULL,
		// если родительского окна нет.
		message,
		// Указатель на строку, содержащую текст сообщения.
		"Error",
		// Указатель на строку, содержащую текст заголовка диалогового окна.
		MB_OK
		// Параметр содержит комбинацию флагов, задающих количество и типы
		// кнопок в диалоговом окне, а также наличие заданной пиктограммы.
		);
	}
	// Создаём окно.
	window_description=CreateWindow
	(
	"window_class",
	// Имя класса окна.
	"Calculation free",
	// Имя окна.
	WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX | WS_MAXIMIZEBOX,
	// Стиль окна.
	CW_USEDEFAULT,
	// Параметр задаёт горизонтальную позицию левого верхнего угла окна.
	// Если ему присвоено значение CW_USEDEFAULT, то система будет
	// использовать значения x и y по умолчанию.
    0,
	// Параметр задаёт вертикальюу позицию левого верхнего угла окна.
	// Если параметр x имеет значение CW_USEDEFAULT, то значение параметра
	// y игнорируется.
	640,
	// Параметр задаёт ширину окна в пикселах. Если ему присвоено значение
	// CW_USEDEFAULT, то система будет использовать значения width и height
	// по умолчанию.
    480,
	// Параметр задаёт высоту окна в пикселах. Если параметр width установлен
	// в CW_USEDEFAULT, то значение height игнорируется.
    (HWND)NULL,
	// Дескриптор родительского окна.
	(HMENU)NULL,
	// Дескриптор меню окна или идентификатор элемента управления.
    (HINSTANCE)program_description,
	// Дескриптор, который Windows присваивает запущенной программе (в
	// которой находится оконная процедура для структуры  окна приложения).
	NULL
	// Указатель на данные, передаваемые в сообщении WM_CREATE.
	);

	if (!window_description)
	{
		char message[100]="Cannot create window: ";
		strcat(message, "Calculation 1.0.1");
		MessageBox
		// Функция создаёт, отображает и обслуживает окно сообщений.
		(
		NULL,
		// Дескриптор родительского окна. Он принимает значение NULL,
		// если родительского окна нет.
		message,
		// Указатель на строку, содержащую текст сообщения.
		"Error",
		// Указатель на строку, содержащую текст заголовка диалогового окна.
		MB_OK
		// Параметр содержит комбинацию флагов, задающих количество и типы
		// кнопок в диалоговом окне, а также наличие заданной пиктограммы.
		);
	}
	// Показываем окно.
	ShowWindow
	(
	window_description,
	// Дескриптор окна.
	window_condition
	// Параметр определяет, в каком виде будет показано окно функцией
	// ShowWindow.
	);

	// Структура типа MSG для работы с "очередью сообщений".
//	create_win main_window
//	// Класс create_win, отвечающий за регистрацию оконного класса, создание
//	// окна и показ его на экране.
//	(
//		"Calculation free",
//		// Имя окна.
//		program_description,
//		// Дескриптор программы, в которой находится оконная функция для
//		// структуры  окна приложения.
//		nCmdShow,
//		// Целое значение, которое может быть передано функции ShowWindow.
//		WndProc,
//		// Оконная функция, определяет то, что выводится в клиентскую
//		// область окна, и то, как окну реагировать на пользовательский ввод.
//		"main_menu",
//		// Имя меню.
//		CW_USEDEFAULT,
//		// Параметр задаёт горизонтальную позицию левого верхнего угла окна.
//		// Если ему присвоено значение CW_USEDEFAULT, то система будет
//		// использовать значения x и y по умолчанию.
//		0,
//		// Параметр задаёт вертикальюу позицию левого верхнего угла окна.
//		// Если параметр x имеет значение CW_USEDEFAULT, то значение
//		// параметра y игнорируется.
//		640,
//		// Параметр задаёт ширину окна в пикселах.
//		480
//		// Параметр задаёт высоту окна в пикселах.
//	);

	// Цикл обработки сообщений.
	while
	(
		GetMessage
		// Функция извлекает очередное сообщение. Функция возвращает значение
		// TRUE при извлечении любого сообщения, кроме одного - WM_QUITE.
		// Получив сообщение WM_QUITE, функция возвращает значение FALSE.
		// В результате этого происходит немедленный выход из цикла, и
		// программа (приложение) завершает работу, возвращая операционной
		// системе код возврата msg.wParam.
		(
			&msg,
			// Параметр задаёт адрес структуры типа MSG, в которую помещается
			// выбранное сообщение.
			NULL,
			// Параметр содержит дескриптор окна, принимающего сообщение.
			// Обычно значение этого параметра равно NULL, что позволяет
			// выбрать сообщения для любого окна программы (приложения).
			0,
			0
		)
	)
		{
			TranslateMessage(&msg);
			DispatchMessage(&msg);
		}
	return msg.wParam;
}
//---------------------------------------------------------------------------
LRESULT CALLBACK WndProc
// Оконная функция (процедура) определяет то, что выводится в клиентскую
// область окна, и то, как окну реагировать на событие (сообщение
// (пользовательский ввод)).
(
	HWND window_description,
	// Параметр содержит дескриптор окна, получающего сообщение.
	UINT message,
	// Параметр указывает идентификатор сообщения.
	WPARAM wParam,
	LPARAM lParam
	// Третий и четвёртый параметры содержат дополнительную информацию,
	// которая распознаётся системой в зависимости от типа полученного
	// сообщения.
)
{
	static HINSTANCE program_description_for_dialog_box;
	// Статическая переменная. Дескриптор программы. Используется в
	// функции DialogBox().
	static HMENU menu_description;
	HICON image_description;
//	static char text[1024]="";
//	HANDLE file_description;
//	DWORD number_to_read=0;
//	DWORD number_delivered=0;
//	bool file_present=false;
//	bool file_name_present=true;
//	static OPENFILENAME file_name;
//	static char file[1024];
//	DWORD number_to_write=0;
//	DWORD number_written=0;
	/*
	menu_description	- дескриптор (описатель) меню.
	image_description	- дескриптор (описатель) пиктограммы.
	text				- переменная для хранения текста.
	file_description	- дескриптор (описатель) файла.
	number_to_read		- объём записываемых данных.
	number_delivered	- фактический размер записанных данных.
	file_present		- переменная хранит значение, возвращаемое функцией
							ReadFile. Используется для проверки существования
							файла calculation.txt.
	file_name_present	- переменная хранит значение, возвращаемое функцией
							GetSaveFileName.
	file_name			- структура типа FILENAME для стандартного
							диалогового окна "Save As".
	file				- переменная для стандартного диалогового окна
							"Save As".
	number_to_write		- объём записываемых данных.
	number_written		- фактический размер записанных данных.
	*/

//	HDC hdc;
	// Дескриптор контекста устройства.
	// Контекст устройства описывает физическое устройство вывода информации,
	// например дисплей или принтер. Контекст устройства сохраняет часто
	// используемые графические атрибуты, такие как цвет фона, перо, кисть,
	// шрифт и им подобные параметры.
	PAINTSTRUCT paintstruct;
	// Структура типа PAINTSTRUCT.
	// Поля этой структуры, заполняемые в результате выполнения функции
	// BeginPaint, в дальнейшем используются операционной системой.
	RECT rect;
	// Структура типа RECT.
	// Поля этой структуры задают координаты левого верхнего угла и
	// правого нижнего угла прамоугольника клиентской области окна.
	switch (message)
	// Обычно программист использует оператор switch для определения того,
	// какое сообщение получено и как его обрабатывать.
	// Все сообщения, не обрабатываемые оконной процедурой, должны
	// передаваться системной функции DefWindowProc.
	// Таким образом, программист пишет код только для тех сообщений,
	// которые нуждаются в нестандартной обработке.
	{
	case WM_CREATE:
		// Это сообщение посылается, когда программа создаёт окно вызовом
		// функции CreateWindow или CreateWindowEx. Оконная функция получает
		// это сообщение, когда окно уже создано, но ещё не показано на экране.
		// Поэтому, обрабатывая это сообщение, можно изменить характеристики
		// окна либо выполнить некоторые инициализирующие действия, например
		// открыть необходимые файлы.
		program_description_for_dialog_box=GetModuleHandle(NULL);
		// Функция GetModuleHandle извлекает дескриптор указанного модуля.
		// Если параметр - пусто (NULL), GetModuleHandle возвращает
		// дескриптор файла, используемый, чтобы создать вызывающий процесс
		// (.EXE файл).
		image_description=LoadIcon
		// Функция LoadIcon загружает ресурс пиктограммы из выполняемого
		// файла (.exe), ассоциированного с экземпляром программы.
		(
			program_description_for_dialog_box,
			MAKEINTRESOURCE(IDI_IMAGE)
		);
		SetClassLong(window_description, GCL_HICON, (LONG)image_description);
		SetClassLong(window_description, GCL_HICONSM, (LONG)image_description);
    	// Функция модифицирует поле hIcon в структуре оконного класса.
		menu_description=GetMenu
		// Функция получает дескриптор меню верхнего уровня.
		(
			window_description
			// Дескриптор окна, получающего сообщение.
		);
		EnableMenuItem
		// Функция включает или делает недоступным пункт меню.
		(
			menu_description,
			// Дескриптор меню.
			MI_SAVE,
			// Пункт меню, который будет включен или сделан недоступным.
			MF_BYCOMMAND | MF_GRAYED
			// Флаг пункта меню.
		);
		EnableMenuItem
		// Функция включает или делает недоступным пункт меню.
		(
			menu_description,
			// Дескриптор меню.
			MI_COST_HOUR,
			// Пункт меню, который будет включен или сделан недоступным.
			MF_BYCOMMAND | MF_GRAYED
			// Флаг пункта меню.
		);
		break;
	case WM_PAINT:
		// Это сообщение уведомляет программу, что часть или вся клиентская
		// область окна недействительна и её следует перерисовать.
//		hdc=BeginPaint
		BeginPaint
		// Функция возвращает дескриптор контекста устройства для
		// клиентской области окна.
		(
			window_description,
			// Дескриптор окна.
			&paintstruct
			// Указатель на структуру типа PAINTSTRUCT.
		);

		GetClientRect
		// Функция предназначена для получения размеров клиентской области
		// окна.
		// Результат работы функции помещается в переменную типа RECT. 
		(
			window_description,
			// Дескриптор окна.
			&rect
			// Указатель на структуру типа RECT.
		);
		EndPaint
		// Функция освобождает контекст устройства.
		(
		window_description,
		// Дескриптор окна.
		&paintstruct
		// Указатель на структуру типа PAINTSTRUCT.
		);
    	break;
	case WM_COMMAND:
	// Сообщение посылается, когда пользователь выбирает команду меню.
		switch(LOWORD(wParam))
		{
		case MI_PRIME_COST:
		// Сообщение о выборе пункта меню "Расчёт стоимости изготовления
		// изделия".
			DialogBox
			// Функция создаёт и выводит на экран модальное диалоговое окно.
			(
				program_description_for_dialog_box,
				// Дескриптор программы (статическая переменная).
				"prime_cost",
				// Имя шаблона диалогового окна.
				window_description,
				// Дескриптор окна владельца, в котором открывается диалоговое
				// окно.
				(DLGPROC)dialog_function_for_prime_cost
				// Оконная функция для диалогового окна.
			);
			break;
		case MI_STRETCH:
		// Сообщение о выборе пункта меню "Расчёт натяжения стропа".
			DialogBox
			// Функция создаёт и выводит на экран модальное диалоговое окно.
			(
				program_description_for_dialog_box,
				// Дескриптор программы (статическая переменная).
				"sling",
				// Имя шаблона диалогового окна.
				window_description,
				// Дескриптор окна владельца, в котором открывается диалоговое
				// окно.
				(DLGPROC)dialog_function_for_sling
				// Оконная функция для диалогового окна.
			);
			break;
		case MI_LICENSE:
		// Сообщение о выборе пункта меню "Лицензионный договор".
			DialogBox
			// Функция создаёт и выводит на экран модальное диалоговое окно.
			(
				program_description_for_dialog_box,
				// Дескриптор программы (статическая переменная).
				"license",
				// Имя шаблона диалогового окна.
				window_description,
				// Дескриптор окна владельца, в котором открывается диалоговое
				// окно.
				(DLGPROC)dialog_function_for_license
				// Оконная функция для диалогового окна.
			);
        	break;
		case MI_ABOUT:
		// Сообщение о выборе пункта меню "О программе".
			DialogBox
			(
				program_description_for_dialog_box,
				// Дескриптор программы (статическая переменная).
				"about",
				// Имя шаблона диалогового окна.
				window_description,
				// Дескриптор окна владельца, в котором открывается диалоговое
				// окно.
				(DLGPROC)dialog_function_for_about
            	// Оконная функция для диалогового окна.
			);
        	break;
		case MI_EXIT:
    	// Сообщение о выборе пункта меню "Выход".
		DestroyWindow
		// Функция разрушает указанное в её параметре окно. Для этого она
		// посылает окну сообщение WM_DESTROY.
		(
			window_description
			// Дескриптор окна.
		);
			break;		
		default:
        	break;
		}
    	break;
	case WM_CLOSE:
		// Сообщение WM_CLOSE появляется, когда пользователь щелкает мышью
		// на кнопке закрытия окна или нажимает комбинацию клавиш Alt+F4.
		DestroyWindow
		// Функция разрушает указанное в её параметре окно. Для этого она
		// посылает окну сообщение WM_DESTROY.
		(
			window_description
			// Дескриптор окна.
		);
		break;
	case WM_DESTROY:
		PostQuitMessage(0);
		// Функция посылает окну сообщение WM_QUITE.
		// В результате этого происходит немедленный выход из цикла
		// обработки сообщений, и программа (приложение) завершает работу,
		// возвращая операционной системе код возврата msg.wParam.
		break;
	default:
		return DefWindowProc(window_description, message, wParam, lParam);
		// Функция обеспечивает стандартную обработку сообщений, которые
		// явно не обрабатываются прикладной задачей.
	}
	return 0;
}

//---------------------------------------------------------------------------

BOOL	CALLBACK dialog_function_for_prime_cost
// Оконная функция для диалогового окна "Расчёт стоимости изготовления
// изделия".
(
	HWND dialog_window_description,
	// Параметр содержит дескриптор диалогового окна "Расчёт стоимости
	// изготовления изделия", получающего сообщение.
	UINT message,
	// Параметр указывает идентификатор сообщения.
	WPARAM wparam,
	LPARAM lparam
	// Третий и четвёртый параметры содержат дополнительную информацию,
	// которая распознаётся системой в зависимости от типа полученного
	// сообщения.
)
{
	HDC hdc;
	// Дескриптор контекста устройства.
	// Контекст устройства описывает физическое устройство вывода информации,
	// например дисплей или принтер. Контекст устройства сохраняет часто
	// используемые графические атрибуты, такие как цвет фона, перо, кисть,
	// шрифт и им подобные параметры.
	PAINTSTRUCT paintstruct;
	// Структура типа PAINTSTRUCT.
	// Поля этой структуры, заполняемые в результате выполнения функции
	// BeginPaint, в дальнейшем используются операционной системой.
	RECT rect;
	// Структура типа RECT.
	// Поля этой структуры задают координаты левого верхнего угла и
	// правого нижнего угла прамоугольника клиентской области окна.
	static char text[1024]="";
	static float t=5.4, cost_hour=1020.0, cost_manufacture=0.0;
	prime_cost vanguard(5.4, 1020.0);
	bool input_range=true;
	/*
	text			- переменная для хранения текста.
	t				- время построения изделия, часов.
	cost_hour		- Приведенная стоимость одного часа работы установки, грн.
	cost_manufacture- cтоимость изготовления изделия, грн.
	vanguard		- объект структуры prime_cost для расчёта стоимости
					  изготовления изделия, грн.
	input_range		- индикатор отклонений от допустимых значений.
	*/
	switch(message)
	// Обычно программист использует оператор switch для определения того,
	// какое сообщение получено и как его обрабатывать.
	// Для всех сообщений, не обрабатываемых в программе, надо просто
	// завершить оконную функцию, вернув значение FALSE.
	// Таким образом, программист пишет код только для тех сообщений,
	// которые нуждаются в нестандартной обработке.
	{
 	case WM_INITDIALOG:
	// Сообщение о создании диалогового окна.
		return TRUE;
	case WM_PAINT:
	// Это сообщение уведомляет программу, что часть или вся клиентская
	// область окна недействительна и её следует перерисовать.
		hdc=BeginPaint
		// Функция возвращает дескриптор контекста устройства для
		// клиентской области окна.
		(
			dialog_window_description,
			// Дескриптор окна.
			&paintstruct
			// Указатель на структуру типа PAINTSTRUCT.
		);
		GetClientRect
		// Функция предназначена для получения размеров клиентской области
		// окна.
		// Результат работы функции помещается в переменную типа RECT.
		(
			dialog_window_description,
			// Дескриптор окна.
			&rect
			// Указатель на структуру типа RECT.
		);
		MoveToEx(hdc, 80, 150, NULL);
		// Функция изменяет текущую позицию пера.
		LineTo(hdc, 520, 150);
		// Функция рисует отрезок из текущей позиции пера до точки x, y.
		EndPaint
		// Функция освобождает контекст устройства.
		(
			dialog_window_description,
			// Дескриптор окна.
			&paintstruct
			// Указатель на структуру типа PAINTSTRUCT.
		);
		return TRUE;
	case WM_COMMAND:
	// Сообщение посылается, когда пользователь выбирает команду
	//диалогового окна.
		switch (LOWORD(wparam))
		{
		case ID_CALCULATION:
		// Сообщение о нажатии кнопки "Рассчитать".
			GetDlgItemText
			// Функция получает текст из любого элемента управления.
			// Причёт ей совсем неважно, кнопка это, поле ввода или
			// статическая метка.
			(
				dialog_window_description,
				// Дескриптор диалогового окна.
				ID_TIME,
				// Идентификатор элемента управления, из которого получаем
				// данные.
				// Время построения изделия, часов.
				text,
				// Строка, в которую помещается текст.
				20
				// Длина строки.
			);
			t=atof(text);
			// Функция переводит строку в формат числа с плавающей точкой.
			GetDlgItemText
			// Функция получает текст из любого элемента управления.
			// Причёт ей совсем неважно, кнопка это, поле ввода или
			// статическая метка.
			(
				dialog_window_description,
				// Дескриптор диалогового окна.
				ID_COST_HOUR,
				// Идентификатор элемента управления, из которого получаем
				// данные.
				// Приведенная стоимость одного часа работы установки, грн.
				text,
				// Строка, в которую помещается текст.
				20
				// Длина строки.
			);
			cost_hour=atof(text);
			// Функция переводит строку в формат числа с плавающей точкой.
			if (t<0 || t>100000000)
			// Проверка введённого значения в поле "Время построения изделия".
			{
				input_range=false;
				sprintf(text, "Время построения изделия меньше 0 или больше "
				"100000000 часов.");
				MessageBox
				(
					dialog_window_description,
					text,
					"Ошибка ввода",
					MB_ICONWARNING
				);
			}
			if (cost_hour<0 || cost_hour>100000000)
			// Проверка введённого значения в поле "Приведенная стоимость
			// одного часа работы установки".
			{
				input_range=false;
				sprintf(text, "Приведенная стоимость одного часа работы "
				"установки меньше 0 или больше 100000000 грн.");
				MessageBox
				(
					dialog_window_description,
					text,
					"Ошибка ввода",
					MB_ICONWARNING
				);
			}

			if (input_range==true)
			// Расчёт стоимости изготовления изделия, грн.
			{
			vanguard.set_time(t);
			// Присвоение объекту vanguard времени построения изделия, часов.
			vanguard.set_cost_hour(cost_hour);
			// Присвоение объекту vanguard приведенной стоимости одного часа
			// работы установки, грн.
			cost_manufacture=vanguard.calculation();
			// Вычисление стоимости изготовления изделия.			
			gcvt
			// Функция преобразует число с плавающей точкой в строку.
			(
				cost_manufacture,
				20,
				text
			);
			SetDlgItemText
			// Функция записывает текст в элемент управления.
			(
				dialog_window_description,
				// Дескриптор диалогового окна.
				ID_COST_MANUFACTURE,
				// Идентификатор элемента управления, в который записываются
				// данные.
				text
				// Строка, из которой записывается текст.
			);
			}
			return TRUE;
		case ID_EXIT:
		// Сообщение о нажатии кнопки "Выход".		
			EndDialog
			// Функция закрывает диалоговое окно и завершает выполнение
			// функции DialogBox().
			(
				dialog_window_description,
				// Дескриптор диалогового окна.
				0
				// Значение, которое передаётся функции DialogBox.
			);
			return TRUE;
		case IDCANCEL:
		// Сообщение о нажатии сочетания клавиш Alt+F4.
			EndDialog
			// Функция закрывает диалоговое окно и завершает выполнение
			// функции DialogBox().
			(
				dialog_window_description,
				// Дескриптор диалогового окна.
				0
				// Значение, которое передаётся функции DialogBox.
			);
			return TRUE;
		}
	default:
		break;
	}
	return FALSE;
	// Для всех сообщений, не обрабатываемых в программе, надо просто
	// завершить оконную функцию, вернув значение FALSE.
}

//----------------------------------------------------------------------------

BOOL	CALLBACK dialog_function_for_sling
// Оконная функция для диалогового окна "Расчёт натяжения стропа".
(
	HWND dialog_window_description,
	// Параметр содержит дескриптор диалогового окна "Расчёт натяжения
	// стропа", получающего сообщение.
	UINT message,
	// Параметр указывает идентификатор сообщения.
	WPARAM wparam,
	LPARAM lparam
	// Третий и четвёртый параметры содержат дополнительную информацию,
	// которая распознаётся системой в зависимости от типа полученного
	// сообщения.
)
{
	HDC hdc;
	// Дескриптор контекста устройства.
	// Контекст устройства описывает физическое устройство вывода информации,
	// например дисплей или принтер. Контекст устройства сохраняет часто
	// используемые графические атрибуты, такие как цвет фона, перо, кисть,
	// шрифт и им подобные параметры.
	PAINTSTRUCT paintstruct;
	// Структура типа PAINTSTRUCT.
	// Поля этой структуры, заполняемые в результате выполнения функции
	// BeginPaint, в дальнейшем используются операционной системой.
	RECT rect;
	// Структура типа RECT.
	// Поля этой структуры задают координаты левого верхнего угла и
	// правого нижнего угла прамоугольника клиентской области окна.
	static float S=25.0, Q=50.0, a_degree=60.0, a_radian=1.047;
	static int n=4;
	static char text[1024]="";
	static OPENFILENAME file_name;
	static char file[1024];
	bool file_name_present=true;
	bool input_range=true;
	HANDLE file_handle;
	DWORD number_to_write=0;
	DWORD number_written=0;
	/*
	S 				- натяжение стропа, кг.
	Q 				- масса груза, кг.
	n 				- число ветвей.
	a_degree		- угол наклона стропа к вертикали, °.
	a_radian		- угол наклона стропа к вертикали, рад.
	text			- переменная для хранения текста.
	file_name		- структура типа FILENAME для стандартного диалогового
					  окна "Save As".
	file			- переменная для стандартного диалогового окна "Save As".
	return_value	- переменная для функции GetSaveFileName.
	input_range		- индикатор отклонений от допустимых значений.
	file_handle		- дескриптор (описатель) файла.
	number_to_write	- объём записываемых данных.
	number_written	- фактический размер записанных данных.
	*/

	switch(message)
	// Обычно программист использует оператор switch для определения того,
	// какое сообщение получено и как его обрабатывать.
	// Для всех сообщений, не обрабатываемых в программе, надо просто
	// завершить оконную функцию, вернув значение FALSE.
	// Таким образом, программист пишет код только для тех сообщений,
	// которые нуждаются в нестандартной обработке.
	{
	case WM_INITDIALOG:
	// Сообщение о создании диалогового окна.
		// Инициализация структуры file_name.
		file_name.lStructSize=sizeof(OPENFILENAME);
    	// Параметр определяет длину структуры в байтах.		
		file_name.hwndOwner=dialog_window_description;
    	// Дескриптор окна, владеющего диалоговым окно.		
		file_name.lpstrFilter="Текстовые файлы *.txt\0*.txt\0Все файлы\0"
		"*.*\0\0";
		// Указатель на буфер, в котором находятся пары нуль-терминированных
		// (null-terminated) строк для фильтра.
		file_name.lpstrFile=file;
		// Указатель на буфер, который содержит полный путь, имя и
		// расширение файла, введённого в поле "Имя файла" функции
		// GetSaveFileName.
		file_name.nMaxFile=sizeof(file);
		// Определяет размер буфера, на который указывает параметр lpstrFile.    
		file_name.lpstrDefExt="txt";
		// Указатель на буфер, в котором находится расширение по умолчанию.    
		return TRUE;
	case WM_PAINT:
	// Это сообщение уведомляет программу, что часть или вся клиентская
	// область окна недействительна и её следует перерисовать.
		hdc=BeginPaint
		// Функция возвращает дескриптор контекста устройства для
		// клиентской области окна.
		(
			dialog_window_description,
			// Дескриптор окна.
			&paintstruct
			// Указатель на структуру типа PAINTSTRUCT.
		);
		GetClientRect
		// Функция предназначена для получения размеров клиентской области
		// окна.
		// Результат работы функции помещается в переменную типа RECT.
		(
			dialog_window_description,
			// Дескриптор окна.
			&rect
			// Указатель на структуру типа RECT.
		);
		// Рисование груза со стропами.
		MoveToEx(hdc, 200, 120, NULL);
		// Функция изменяет текущую позицию пера.
		LineTo(hdc, 360, 120);
		// Функция рисует отрезок из текущей позиции пера до точки x, y.
		MoveToEx(hdc, 240, 100, NULL);	LineTo(hdc, 400, 100);
		MoveToEx(hdc, 200, 120, NULL);	LineTo(hdc, 240, 100);
		MoveToEx(hdc, 360, 120, NULL);	LineTo(hdc, 400, 100);
		MoveToEx(hdc, 240, 100, NULL);	LineTo(hdc, 300, 50);
		MoveToEx(hdc, 400, 100, NULL);	LineTo(hdc, 300, 50);
		MoveToEx(hdc, 200, 120, NULL);	LineTo(hdc, 300, 50);
		MoveToEx(hdc, 360, 120, NULL);	LineTo(hdc, 300, 50);
		MoveToEx(hdc, 200, 120, NULL);	LineTo(hdc, 200, 140);
		MoveToEx(hdc, 360, 120, NULL);	LineTo(hdc, 360, 140);
		MoveToEx(hdc, 400, 100, NULL);	LineTo(hdc, 400, 120);
		MoveToEx(hdc, 200, 140, NULL);	LineTo(hdc, 360, 140);
		MoveToEx(hdc, 360, 140, NULL);	LineTo(hdc, 400, 120);
		MoveToEx(hdc, 300, 50, NULL);	LineTo(hdc, 300, 110);
		Arc(hdc, 250, 60, 350, 105, 300, 160, 550, 160);
		MoveToEx(hdc, 300, 140, NULL);	LineTo(hdc, 300, 160);
		MoveToEx(hdc, 299, 152, NULL);	LineTo(hdc, 299, 156);
		MoveToEx(hdc, 301, 152, NULL);	LineTo(hdc, 301, 156);
		MoveToEx(hdc, 395, 90, NULL);	LineTo(hdc, 373, 79);
		MoveToEx(hdc, 382, 84, NULL);	LineTo(hdc, 377, 81);
		MoveToEx(hdc, 382, 82, NULL);	LineTo(hdc, 377, 79);
		MoveToEx(hdc, 460, 117, NULL);	LineTo(hdc, 520, 117);
		MoveToEx(hdc, 80, 310, NULL);	LineTo(hdc, 520, 310);
		EndPaint
		// Функция освобождает контекст устройства.
		(
			dialog_window_description,
			// Дескриптор окна.
			&paintstruct
			// Указатель на структуру типа PAINTSTRUCT.
		);
		return TRUE;
	case WM_COMMAND:
	// Сообщение посылается, когда пользователь выбирает команду
	//диалогового окна.
		switch (LOWORD(wparam))
		{
		case ID_CALCULATION:
		// Сообщение о нажатии кнопки "Расчёт".
			input_range=true;
			GetDlgItemText
			// Функция получает текст из любого элемента управления.
			// Причёт ей совсем неважно, кнопка это, поле ввода или
			// статическая метка.
			(
				dialog_window_description,
				// Дескриптор диалогового окна.
				ID_MASS,
				// Идентификатор элемента управления, из которого получаем
				// данные.
            	// Масса груза.
				text,
				// Строка, в которую помещается текст.
				20
				// Длина строки.
			);
			Q=atof(text);
			// Функция переводит строку в формат числа с плавающей точкой.
			GetDlgItemText
			(
				dialog_window_description,
				ID_NUMBER,
				// Идентификатор элемента управления, из которого получаем
				// данные.
				// Число ветвей.
				text,
				20
			);
			n=atof(text);
			// Функция переводит строку в формат числа с плавающей точкой.			
			GetDlgItemText
			(
				dialog_window_description,
				ID_ANGLE,
				// Идентификатор элемента управления, из которого получаем
				// данные.
            	// Угол наклона стропа к вертикали.
				text,
				20
			);
			a_degree=atof(text);
			// Функция переводит строку в формат числа с плавающей точкой.
			if (Q<0 || Q>100000000)
			// Проверка введённого значения в поле "масса груза".
			{
				input_range=false;
 				sprintf(text, "Масса груза меньше 0 или больше 100000000 кг.");
				MessageBox
				(
					dialog_window_description,
					text,
					"Ошибка ввода",
					MB_ICONWARNING
				);
			}
			if (n<1)
			// Проверка введённого значения в поле "число ветвей".
			{
				input_range=false;
				sprintf(text, "Число строп меньше 1");
				MessageBox
				(
					dialog_window_description,
					text,
					"Ошибка ввода",
					MB_ICONWARNING
				);
			}
			if (a_degree<0 || a_degree>89.999)
			// Проверка введённого значения в поле "угол наклона стропа".
			{
				input_range=false;
				sprintf(text, "Угол меньше 0°, или больше 89.99°");
				MessageBox
				(
					dialog_window_description,
                	text,
					"Ошибка ввода",
					MB_ICONWARNING
				);
			}
			if (input_range==true)
			// Расчёт натяжения стропа
			{
				a_radian=(3.1415926*a_degree)/180;
				// Перевод угла в градусах в угол в радианах.
				S=Q/(n*cos(a_radian));
				// Расчёт натяжения стропа.
				gcvt
				// Функция преобразует число с плавающей точкой в строку.
				(
					S,
					20,
					text
				);
				SetDlgItemText
				// Функция записывает текст в элемент управления.
				(
					dialog_window_description,
					ID_TAUT,
					text
				);
			}
			return TRUE;
		case ID_SAVE:
		// Сообщение о нажатии кнопки "Сохранить расчёт".
            strcpy(file, "");
			// Функция копирует содержимое строки в указанный буфер. В
			// данном случае функция очищает содержимое переменной file.
			file_name_present=GetSaveFileName(&file_name);
			// Функция создаёт стандартное диалоговое окно "Save As".
			if (file_name_present==true)
			{
				file_handle=CreateFile
				// Функция создаёт указатель на новоe устройство (файл).
				(
					file_name.lpstrFile, // Указатель на имя файла.
					//(устройства).
					GENERIC_READ | GENERIC_WRITE,
					// Параметры определяют доступ на чтение и запись.
					FILE_SHARE_READ | FILE_SHARE_WRITE,
					// Общий доступ на чтение и запись к данному файлу.
					// То есть файл будет доступен при одновременном
					// использовании несколькими процессами.
					NULL,
					// Атрибут безопасности неопределён. То есть все
					// дескрипторы будут доступны дочерним процессам
					// вашей программы.
					CREATE_ALWAYS,
					// Параметр указывает на создание нового файла. Если файл
					// существует, то он будет перезаписан.
					FILE_ATTRIBUTE_NORMAL,
					// Параметр FILE_ATTRIBUTE_NORMAL определяет файлу
					//стандартные атрибуты.
					NULL
					// Шаблоны не используются.
				);
				sprintf
                // Функция записывает в переменную text результат расчёта
				// натяжения стропа.
				(
					text,
					"Расчёт натяжения стропа. \n\nНатяжение стропа S, "
					"кг, \n\nS=Q/(n·cos a), \n\nгде\nQ - масса груза, кг;"
					" \nn - число ветвей, шт; \na - угол наклона стропа к"
					" вертикали, °. \n\nS=%f, кг; \n\nQ=%f, кг; \nn=%d, шт; "
					"\na=%f, °. \n", S, Q, n, a_degree
				);
				number_to_write=strlen(text);
				WriteFile
				// Запись в файл результата расчёта.
				(
					file_handle,	// Дескриптор (описатель) файла.
					text,			// Указатель на буфер - откуда записываем
									// данные в файл.
					number_to_write,// объём записываемых данных.
					&number_written,// фактический размер записанных данных.
					NULL			// Флаг режима доступа к файлу.
				);
				CloseHandle(file_handle);
				// Функция освобождает указатель на устройство (файл).

				file_handle=CreateFile
				// Функция создаёт указатель на новоe устройство (файл).
				(
					"sling.txt",
					// Указатель на имя файла (устройства).
					GENERIC_READ | GENERIC_WRITE,
					// Параметры определяют доступ на чтение и запись.
					FILE_SHARE_READ | FILE_SHARE_WRITE,
					// Общий доступ на чтение и запись к данному файлу.
					// То есть файл будет доступен при одновременном
					// использовании несколькими процессами.
					NULL,
					// Атрибут безопасности неопределён. То есть все
					// дескрипторы будут доступны дочерним процессам вашего
					// приложения.
					CREATE_ALWAYS,
					// Параметр указывает на создание нового файла. Если файл
					// существует, то он будет перезаписан.
					FILE_ATTRIBUTE_NORMAL,
					// Параметр FILE_ATTRIBUTE_NORMAL определяет файлу
					// стандартные атрибуты.
					NULL
					// Шаблоны не используются.
				);
				strcpy(text, "");
				// Функция очищает содержимое переменной text.
				sprintf
				// Функция записывает в переменную text результат расчёта
				// натяжения стропа.
				(
					text,
					"Расчёт натяжения стропа. \n\nНатяжение стропа"
					" S, кг, \n\nS=Q/(n·cos a), \n\nгде\nQ - масса груза,"
					" кг; \nn - число ветвей, шт; \na - угол наклона стропа"
					" к вертикали, °. \n\nS=%f, кг; \n\nQ=%f, кг; \nn=%d, шт;"
					" \na=%f, °. \n",
					S, Q, n, a_degree
				);
				number_to_write=strlen(text);
				WriteFile
				// Запись в файл sling.txt, результата расчёта. Информация
				//из файла sling.txt используется при выводе результата
				//расчёта в главном окне программы.
				(
					file_handle,	// Дескриптор (описатель) файла.
					text,			// Указатель на буфер - откуда записываем
									// данные в файл.
					number_to_write,// объём записываемых данных.
					&number_written,// фактический размер записанных данных.
					NULL			// Флаг режима доступа к файлу.
				);
				CloseHandle(file_handle);
				// Функция освобождает указатель на устройство (файл).
			}
			else
			{
				MessageBox
				(
					dialog_window_description,
					file_name.lpstrFile,
					"Отказ от выбора или ошибка",
					MB_ICONWARNING
				);
			}
			return TRUE;
		case ID_EXIT:
		// Сообщение о нажатии кнопки "Выход".
			InvalidateRect
			// Функция генерирует сообщение WM_PAINT.
			(
				NULL,
				// Дескриптор окна, у которого изменился обновляемый регион.
				// Если этот параметр равен NULL, то система обновляет и
				// перерисовывает все окна программы.
				NULL,
				// Указатель на структуру типа RECT, содержащую клиентские
				// координаты прямоугольника, который добавляется к
				// обновляемому региону. Если этот параметр равен NULL, то
            	// к обновляемому региону добавляется вся клиентская область.
				FALSE
				// Флаг, определяющий, будет ли стираться фон обновляемого
				//региона.
			);
			EndDialog
			// Функция закрывает диалоговое окно и завершает выполнение
			// функции DialogBox().
			(
				dialog_window_description,
				// Дескриптор диалогового окна.
				0
				// Значение, которое передаётся функции DialogBox.
			);
			return TRUE;
		case IDCANCEL:
		// Сообщение о нажатии сочетания клавиш Alt+F4.
			InvalidateRect
			// Функция генерирует сообщение WM_PAINT.
			(
				NULL,
				// Дескриптор окна, у которого изменился обновляемый регион.
				// Если этот параметр равен NULL, то система обновляет и
				// перерисовывает все окна программы.
				NULL,
				// Указатель на структуру типа RECT, содержащую клиентские
				// координаты прямоугольника, который добавляется к
				// обновляемому региону. Если этот параметр равен NULL, то
            	// к обновляемому региону добавляется вся клиентская область.
				FALSE
				// Флаг, определяющий, будет ли стираться фон обновляемого
				//региона.
			);
			EndDialog
			// Функция закрывает диалоговое окно и завершает выполнение
			// функции DialogBox().
			(
				dialog_window_description,
				// Дескриптор диалогового окна.
				0
				// Значение, которое передаётся функции DialogBox.
			);
			return TRUE;
		}
	default:
		break;
	}
	return FALSE;
	// Для всех сообщений, не обрабатываемых в программе, надо просто
	// завершить оконную функцию, вернув значение FALSE.
}

//----------------------------------------------------------------------------

BOOL	CALLBACK dialog_function_for_license
// Оконная функция для диалогового окна "Лицензионный договор".
(
	HWND dialog_window_description,
	// Параметр содержит дескриптор диалогового окна "Лицензионный договор",
	// получающего сообщение.
	UINT message,
	// Параметр указывает идентификатор сообщения.
	WPARAM wparam,
	LPARAM lparam
	// Третий и четвёртый параметры содержат дополнительную информацию,
	// которая распознаётся системой в зависимости от типа полученного
	// сообщения.
)
{
	PAINTSTRUCT paintstruct;
	// Структура типа PAINTSTRUCT.
	// Поля этой структуры, заполняемые в результате выполнения функции
	// BeginPaint, в дальнейшем используются операционной системой.
	RECT rect;
	// Структура типа RECT.
	// Поля этой структуры задают координаты левого верхнего угла и
	// правого нижнего угла прамоугольника клиентской области окна.
switch(message)
	// Обычно программист использует оператор switch для определения того,
	// какое сообщение получено и как его обрабатывать.
	// Для всех сообщений, не обрабатываемых в программе, надо просто
	// завершить оконную функцию, вернув значение FALSE.
	// Таким образом, программист пишет код только для тех сообщений,
	// которые нуждаются в нестандартной обработке.
	{
 	case WM_INITDIALOG:
	// Сообщение о создании диалогового окна.
		return TRUE;
	case WM_PAINT:
	// Это сообщение уведомляет программу, что часть или вся клиентская
	// область окна недействительна и её следует перерисовать.
		BeginPaint
		// Функция возвращает дескриптор контекста устройства для
		// клиентской области окна.
		(
			dialog_window_description,
			// Дескриптор окна.
			&paintstruct
			// Указатель на структуру типа PAINTSTRUCT.
		);
		GetClientRect
		// Функция предназначена для получения размеров клиентской области
		// окна.
		// Результат работы функции помещается в переменную типа RECT.
		(
			dialog_window_description,
			// Дескриптор окна.
			&rect
			// Указатель на структуру типа RECT.
		);
		EndPaint
		// Функция освобождает контекст устройства.
		(
			dialog_window_description,
			// Дескриптор окна.
			&paintstruct
			// Указатель на структуру типа PAINTSTRUCT.
		);
		return TRUE;
	case WM_COMMAND:
	// Сообщение посылается, когда пользователь выбирает команду
	//диалогового окна.
		switch (LOWORD(wparam))
		{
		case ID_OK_LICENSE:
 		// Сообщение о нажатии кнопки "OK".
			EndDialog
			// Функция закрывает диалоговое окно и завершает выполнение
			// функции DialogBox().
			(
				dialog_window_description,
				// Дескриптор диалогового окна.
				0
				// Значение, которое передаётся функции DialogBox.
			);
			return TRUE;
		case IDCANCEL:
		// Сообщение о нажатии сочетания клавиш Alt+F4.
			EndDialog
			// Функция закрывает диалоговое окно и завершает выполнение
			// функции DialogBox().
			(
				dialog_window_description,
				// Дескриптор диалогового окна.
				0
				// Значение, которое передаётся функции DialogBox.
			);
			return TRUE;
		}
	default:
		break;
	}
	return FALSE;
	// Для всех сообщений, не обрабатываемых в программе, надо просто
	// завершить оконную функцию, вернув значение FALSE.
}

//----------------------------------------------------------------------------

BOOL	CALLBACK dialog_function_for_about
// Оконная функция для диалогового окна "О программе".
(
	HWND dialog_window_description,
	// Параметр содержит дескриптор диалогового окна "О программе",
	// получающего сообщение.
	UINT message,
	// Параметр указывает идентификатор сообщения.
	WPARAM wparam,
	LPARAM lparam
	// Третий и четвёртый параметры содержат дополнительную информацию,
	// которая распознаётся системой в зависимости от типа полученного
	// сообщения.
)
{
	PAINTSTRUCT paintstruct;
	// Структура типа PAINTSTRUCT.
	// Поля этой структуры, заполняемые в результате выполнения функции
	// BeginPaint, в дальнейшем используются операционной системой.
	RECT rect;
	// Структура типа RECT.
	// Поля этой структуры задают координаты левого верхнего угла и
	// правого нижнего угла прамоугольника клиентской области окна.

	switch(message)
	// Обычно программист использует оператор switch для определения того,
	// какое сообщение получено и как его обрабатывать.
	// Для всех сообщений, не обрабатываемых в программе, надо просто
	// завершить оконную функцию, вернув значение FALSE.
	// Таким образом, программист пишет код только для тех сообщений,
	// которые нуждаются в нестандартной обработке.
	{
 	case WM_INITDIALOG:
	// Сообщение о создании диалогового окна.
		return TRUE;
	case WM_PAINT:
	// Это сообщение уведомляет программу, что часть или вся клиентская
	// область окна недействительна и её следует перерисовать.
		BeginPaint
		// Функция возвращает дескриптор контекста устройства для
		// клиентской области окна.
		(
			dialog_window_description,
			// Дескриптор окна.
			&paintstruct
			// Указатель на структуру типа PAINTSTRUCT.
		);
		GetClientRect
		// Функция предназначена для получения размеров клиентской области
		// окна.
		// Результат работы функции помещается в переменную типа RECT.
		(
			dialog_window_description,
			// Дескриптор окна.
			&rect
			// Указатель на структуру типа RECT.
		);
		EndPaint
		// Функция освобождает контекст устройства.
		(
			dialog_window_description,
			// Дескриптор окна.
			&paintstruct
			// Указатель на структуру типа PAINTSTRUCT.
		);
		return TRUE;
	case WM_COMMAND:
	// Сообщение посылается, когда пользователь выбирает команду
	//диалогового окна.
		switch (LOWORD(wparam))
		{
		case ID_OK_ABOUT:
		// Сообщение о нажатии кнопки "OK".
			EndDialog
			// Функция закрывает диалоговое окно и завершает выполнение
			// функции DialogBox().
			(
				dialog_window_description,
				// Дескриптор диалогового окна.
				0
				// Значение, которое передаётся функции DialogBox.
			);
			return TRUE;
		case IDCANCEL:
		// Сообщение о нажатии сочетания клавиш Alt+F4.
			EndDialog
			// Функция закрывает диалоговое окно и завершает выполнение
			// функции DialogBox().
			(
				dialog_window_description,
				// Дескриптор диалогового окна.
				0
				// Значение, которое передаётся функции DialogBox.
			);
			return TRUE;
		}
	default:
		break;
	}
	return FALSE;
	// Для всех сообщений, не обрабатываемых в программе, надо просто
	// завершить оконную функцию, вернув значение FALSE.
}


/*
						Список источников информации

1	Джесс Либерти, Брэдли Джонс. Освой самостоятельно С++ за 21 день, 5-е
	издание.: Пер. с англ. - М.: Издательский дом "Вильямс", 2008. - 768 с.:
	ил.- Парал. тит. англ.
2	Щупак Ю. А. Win32 API. Разработка приложений для Windows. – СПб.: Питер,
	2008. – 592 с.: ил.
3	Бобровский С.И. Технологии C++ Builder. Разработка приложений для бизнеса.
	Учебный курс. — СПб.: Питер, 2007.
4	Турбо С. Руководство пользователя. Версия 2.0. Москва, 1989.
5	Культин Н. Основы программирования в Turbo C++., "БХВ - Петербург",
	2007., 464 с.   http://tid.com.ua
6	Економіка підприємства: Підручник / За заг. ред. д-ра екон. наук, проф.
	С.Ф. Покропивного. - К.: КНЕУ, 2003. - 608с. - Рос. мовою.
7	Богомаз И.В. Теоретическая механика. Том 1. Кинематика. Статика: Тексты
	лекций. - М.: Изд-во АСВ, 2005. - 190с., 176илл.
8	http://www.rpt.com.ua/default.aspx?select=faq&name=Price
	Стоимость построения изделия (произведение времени построения изделия
	на приведенную стоимость одного часа работы установки).
9	Коноваленко В. Авторське право: автору, редактору, видавцю. - Х.:
	Фактор, 2007. - 496с.
10	http://radiofront.narod.ru/htm/prog/htm/indexprog.html
11	http://w32api.narod.ru


	Для нематериальных активов, период использования которых невозможно
установит, норма амортизации определяется в расчёте на 10 лет, т.е. 10%
в год.
	Оценить стоимость нематериальных активов можно по методу освобождения
от роялти. Стоимость уникальных нематериальных активов можно расчитать
методом восстановительной стоимости.
*/

